---
description: >-
  进程线程协程思想诞生的背后，体现的是不同的计算场景对服务编程模型的不同要求。计算是一个非常宽泛的概念，它可以是狭义上的计算任务，如数值计算等，也可以是广义上的对请求的处理。我们先介绍下常见的任务类型以及适用的编程模型，有助于我们更加充分理解协程引入的背景和意义。
---

# 服务编程模型

我们先了解下常见的任务类型和服务编程模型，了解了这些内容之后，有助于我们加深对协程的理解。

### 常见任务类型

计算机要处理的任务，根据任务本身的性质，大致包括：计算密集型任务、IO密集型任务、混合型任务。

### 服务编程模型

常见的服务编程模型，根据服务并发处理的组织形式，大致包括：单/多进程、单/多线程、协程。

### 选择合适的编程模型

下面展开描述下几种任务的区别，以及各自适合采用的服务编程模型。

#### 计算密集型任务

需要长时间占据CPU进行计算的任务属于计算密集型任务，这类任务执行所花费的时间大部分都是CPU片上时间，而极少有CPU片下时间。简言之，就是说这类任务执行期间不会主动让度出CPU给其他任务执行。

这类任务，使用多线程编程模型是不合适的，可以考虑使用多进程模型来处理。

多线程得以发挥其并发处理的优势的前提是，线程之间能交替执行，在某个线程实体所依赖的资源暂时不满足时，让度出CPU给其他可以执行的线程实体继续执行。这样在宏观上，多线程在资源有限时可以实现更大程度地并发处理，才可以发挥其优势。但是计算密集型任务，线程没有合适的时机来主动让度CPU给其他线程，一个线程和多个线程相比，并无什么优势。

进程，是操作系统进行资源分配的实体，线程，则是操作系统进行任务调度的实体。通过多进程编程模型，可以整体获得更多的CPU计算资源（时间片），同时结合taskset可以将多个进程分别绑定到不同的CPU或CPU core上，这样多个进程实现并行处理，可以获得更高的并发处理能力。

计算密集型任务，一般是通过多进程编程模型来解决的。

#### IO密集型任务

任务执行期间花费的时间消耗在CPU上的片上时间极少，大部分都消耗在IO上，可能是文件IO（如nfs server），也可能是网络IO（rpc服务）。

这类任务，主要的优化项在于对IO的非阻塞处理，不管是单/多进程、单/多线程、协程，其根本要处理的问题都是对IO操作的非阻塞优化。

以rpc服务为例，网络IO操作过程中，如果没有对相关socket进行非阻塞处理，那么执行IO操作的线程是一定会被阻塞的，意味着这个线程在网络IO操作完成之前什么其他任务也做不了，只能等到操作系统内核完成该IO操作时才能被重新唤醒恢复执行。不管你有多少个线程，只要并发量一大，这种编程模型实现的服务是根本扛不住的。

但是，对网络IO操作进行非阻塞处理之后，如IO多路复用（如Linux下epoll）、rtsig（实时信号驱动）等，效果就不一样了。这里以IO多路复用为例，线程会被告知何时read ready、何时write ready，执行过程中线程几乎可以立即完成，几乎没有等待时间。通过这种方式，即便是单进程单线程模型也可以获得非常高的性能，典型的业界代表就是redis缓存服务器。

当然了，理论上多线程编程模型会比单线程带来更高的性能，只是理论上，多线程会引入同步互斥相关的操作，锁竞争带来的开销、线程上下文切换带来的开销也会加剧。那多进程单线程呢，多进程多线程呢，我只能说，具体问题具体分析，进行实际的压力测试对服务性能进行量化分析是一个比较靠谱的做法。

线程，在Linux下面其实是轻量级进程LWP来实现的，只不过它与父进程共享了某些计算资源资源，如内存地址空间、名字空间等等，线程数量多了之后，线程切换的开销就不得不考虑了，这也是某些高并发中间件在设计实现时采用单线程或线程池来绕过这个问题的原因之一。

线程切换需要进入内核，涉及到几千条指令、几十上百个寄存器的保存恢复，这里的开销是不可忽略的，还有线程栈本身大小，对内存也是一个比较大的消耗。协程是更加轻量级的任务实体，以goroutine为例或者libmill中的coroutine为例，协程切换只涉及到几百条指令执行、几个寄存器的保存恢复，而且协程栈大小比线程小的多，如Linux下goroutine协程栈初始大小2KB，而线程栈2MB，1000倍！

协程，往往还会结合一些Hook系统调用的操作，如hook系统调用read、write，实现“同步编码、异步运行”的效果，不光有助于性能的提升，也有助于编码效率、代码可读性、可维护性的提高。

#### 混合型任务

混合型，指的就是计算密集型、IO密集型两种任务兼而有之，这种情况下就不能做非黑即白的假设了。

同一个服务中同时实现两种任务是否满足要求，也要根据具体情况来分析。比如，多数任务是IO密集型，计算密集型占少数，但是少量的计算密集型任务也可能会导致大量的IO密集型任务无法得到快速有效的响应，这种是否符合预期的设计要求，就需要权衡。

是否应该将两种类型的计算任务进行重构、分离，并对两种类型的服务做针对性的优化、部署，这些都要结合具体的场景、预期性能、成本核算来做权衡。

#### 

